// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIDURY_H_
#define FLATBUFFERS_GENERATED_SIDURY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Vec2;

struct Vec3;

struct Vec4;

struct Quat;

struct NetMsg_UserCmd;
struct NetMsg_UserCmdBuilder;

struct NetMsg_ServerInfo;
struct NetMsg_ServerInfoBuilder;

struct NetMsg_ClientInfo;
struct NetMsg_ClientInfoBuilder;

struct NetMsg_ServerClientInfo;
struct NetMsg_ServerClientInfoBuilder;

struct NetMsg_ServerConnectResponse;
struct NetMsg_ServerConnectResponseBuilder;

struct NetMsg_ClientConnect;
struct NetMsg_ClientConnectBuilder;

struct NetMsg_Disconnect;
struct NetMsg_DisconnectBuilder;

struct NetMsg_ConVar;
struct NetMsg_ConVarBuilder;

struct NetMsg_Paused;
struct NetMsg_PausedBuilder;

struct NetMsg_GameRule;
struct NetMsg_GameRuleBuilder;

struct NetMsg_GameRuleList;
struct NetMsg_GameRuleListBuilder;

struct MsgSrc_Client;
struct MsgSrc_ClientBuilder;

struct MsgSrc_Server;
struct MsgSrc_ServerBuilder;

struct NetMsg_ComponentUpdateData;
struct NetMsg_ComponentUpdateDataBuilder;

struct NetMsg_ComponentUpdate;
struct NetMsg_ComponentUpdateBuilder;

struct NetMsg_EntityUpdate;
struct NetMsg_EntityUpdateBuilder;

struct NetMsg_EntityUpdates;
struct NetMsg_EntityUpdatesBuilder;

struct NetMsg_ComponentUpdates;
struct NetMsg_ComponentUpdatesBuilder;

struct SMF_Command;
struct SMF_CommandBuilder;

struct SMF_Data;
struct SMF_DataBuilder;

struct SMF_Skybox;
struct SMF_SkyboxBuilder;

enum ESiduryProtocolVer : uint16_t {
  ESiduryProtocolVer_Value = 3,
  ESiduryProtocolVer_MIN = ESiduryProtocolVer_Value,
  ESiduryProtocolVer_MAX = ESiduryProtocolVer_Value
};

inline const ESiduryProtocolVer (&EnumValuesESiduryProtocolVer())[1] {
  static const ESiduryProtocolVer values[] = {
    ESiduryProtocolVer_Value
  };
  return values;
}

inline const char * const *EnumNamesESiduryProtocolVer() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameESiduryProtocolVer(ESiduryProtocolVer e) {
  if (::flatbuffers::IsOutRange(e, ESiduryProtocolVer_Value, ESiduryProtocolVer_Value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ESiduryProtocolVer_Value);
  return EnumNamesESiduryProtocolVer()[index];
}

enum ESiduryComponentProtocolVer : uint16_t {
  ESiduryComponentProtocolVer_Value = 2,
  ESiduryComponentProtocolVer_MIN = ESiduryComponentProtocolVer_Value,
  ESiduryComponentProtocolVer_MAX = ESiduryComponentProtocolVer_Value
};

inline const ESiduryComponentProtocolVer (&EnumValuesESiduryComponentProtocolVer())[1] {
  static const ESiduryComponentProtocolVer values[] = {
    ESiduryComponentProtocolVer_Value
  };
  return values;
}

inline const char * const *EnumNamesESiduryComponentProtocolVer() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameESiduryComponentProtocolVer(ESiduryComponentProtocolVer e) {
  if (::flatbuffers::IsOutRange(e, ESiduryComponentProtocolVer_Value, ESiduryComponentProtocolVer_Value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ESiduryComponentProtocolVer_Value);
  return EnumNamesESiduryComponentProtocolVer()[index];
}

enum Net_EPlayerMoveType : int8_t {
  Net_EPlayerMoveType_Walk = 0,
  Net_EPlayerMoveType_NoClip = 1,
  Net_EPlayerMoveType_Fly = 2,
  Net_EPlayerMoveType_MIN = Net_EPlayerMoveType_Walk,
  Net_EPlayerMoveType_MAX = Net_EPlayerMoveType_Fly
};

inline const Net_EPlayerMoveType (&EnumValuesNet_EPlayerMoveType())[3] {
  static const Net_EPlayerMoveType values[] = {
    Net_EPlayerMoveType_Walk,
    Net_EPlayerMoveType_NoClip,
    Net_EPlayerMoveType_Fly
  };
  return values;
}

inline const char * const *EnumNamesNet_EPlayerMoveType() {
  static const char * const names[4] = {
    "Walk",
    "NoClip",
    "Fly",
    nullptr
  };
  return names;
}

inline const char *EnumNameNet_EPlayerMoveType(Net_EPlayerMoveType e) {
  if (::flatbuffers::IsOutRange(e, Net_EPlayerMoveType_Walk, Net_EPlayerMoveType_Fly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNet_EPlayerMoveType()[index];
}

enum EMsgSrc_Client : uint8_t {
  EMsgSrc_Client_Invalid = 0,
  EMsgSrc_Client_Disconnect = 1,
  EMsgSrc_Client_ConVar = 2,
  EMsgSrc_Client_ClientInfo = 3,
  EMsgSrc_Client_ConnectFinish = 4,
  EMsgSrc_Client_UserCmd = 5,
  EMsgSrc_Client_FullUpdate = 6,
  EMsgSrc_Client_MIN = EMsgSrc_Client_Invalid,
  EMsgSrc_Client_MAX = EMsgSrc_Client_FullUpdate
};

inline const EMsgSrc_Client (&EnumValuesEMsgSrc_Client())[7] {
  static const EMsgSrc_Client values[] = {
    EMsgSrc_Client_Invalid,
    EMsgSrc_Client_Disconnect,
    EMsgSrc_Client_ConVar,
    EMsgSrc_Client_ClientInfo,
    EMsgSrc_Client_ConnectFinish,
    EMsgSrc_Client_UserCmd,
    EMsgSrc_Client_FullUpdate
  };
  return values;
}

inline const char * const *EnumNamesEMsgSrc_Client() {
  static const char * const names[8] = {
    "Invalid",
    "Disconnect",
    "ConVar",
    "ClientInfo",
    "ConnectFinish",
    "UserCmd",
    "FullUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMsgSrc_Client(EMsgSrc_Client e) {
  if (::flatbuffers::IsOutRange(e, EMsgSrc_Client_Invalid, EMsgSrc_Client_FullUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMsgSrc_Client()[index];
}

enum EMsgSrc_Server : uint8_t {
  EMsgSrc_Server_Invalid = 0,
  EMsgSrc_Server_Disconnect = 1,
  EMsgSrc_Server_ConVar = 2,
  EMsgSrc_Server_ClientInfo = 3,
  EMsgSrc_Server_ConnectResponse = 4,
  EMsgSrc_Server_ServerInfo = 5,
  EMsgSrc_Server_ComponentRegistryInfo = 6,
  EMsgSrc_Server_ComponentList = 7,
  EMsgSrc_Server_EntityList = 8,
  EMsgSrc_Server_Paused = 9,
  EMsgSrc_Server_GameRules = 10,
  EMsgSrc_Server_MIN = EMsgSrc_Server_Invalid,
  EMsgSrc_Server_MAX = EMsgSrc_Server_GameRules
};

inline const EMsgSrc_Server (&EnumValuesEMsgSrc_Server())[11] {
  static const EMsgSrc_Server values[] = {
    EMsgSrc_Server_Invalid,
    EMsgSrc_Server_Disconnect,
    EMsgSrc_Server_ConVar,
    EMsgSrc_Server_ClientInfo,
    EMsgSrc_Server_ConnectResponse,
    EMsgSrc_Server_ServerInfo,
    EMsgSrc_Server_ComponentRegistryInfo,
    EMsgSrc_Server_ComponentList,
    EMsgSrc_Server_EntityList,
    EMsgSrc_Server_Paused,
    EMsgSrc_Server_GameRules
  };
  return values;
}

inline const char * const *EnumNamesEMsgSrc_Server() {
  static const char * const names[12] = {
    "Invalid",
    "Disconnect",
    "ConVar",
    "ClientInfo",
    "ConnectResponse",
    "ServerInfo",
    "ComponentRegistryInfo",
    "ComponentList",
    "EntityList",
    "Paused",
    "GameRules",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMsgSrc_Server(EMsgSrc_Server e) {
  if (::flatbuffers::IsOutRange(e, EMsgSrc_Server_Invalid, EMsgSrc_Server_GameRules)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMsgSrc_Server()[index];
}

enum ESMF_Command : uint32_t {
  ESMF_Command_Invalid = 0,
  ESMF_Command_Skybox = 1,
  ESMF_Command_EntityList = 2,
  ESMF_Command_ComponentList = 3,
  ESMF_Command_MIN = ESMF_Command_Invalid,
  ESMF_Command_MAX = ESMF_Command_ComponentList
};

inline const ESMF_Command (&EnumValuesESMF_Command())[4] {
  static const ESMF_Command values[] = {
    ESMF_Command_Invalid,
    ESMF_Command_Skybox,
    ESMF_Command_EntityList,
    ESMF_Command_ComponentList
  };
  return values;
}

inline const char * const *EnumNamesESMF_Command() {
  static const char * const names[5] = {
    "Invalid",
    "Skybox",
    "EntityList",
    "ComponentList",
    nullptr
  };
  return names;
}

inline const char *EnumNameESMF_Command(ESMF_Command e) {
  if (::flatbuffers::IsOutRange(e, ESMF_Command_Invalid, ESMF_Command_ComponentList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesESMF_Command()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quat()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quat, 16);

struct NetMsg_UserCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_UserCmdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLES = 4,
    VT_BUTTONS = 6,
    VT_MOVE_TYPE = 8,
    VT_FLASHLIGHT = 10
  };
  const Vec3 *angles() const {
    return GetStruct<const Vec3 *>(VT_ANGLES);
  }
  int32_t buttons() const {
    return GetField<int32_t>(VT_BUTTONS, 0);
  }
  Net_EPlayerMoveType move_type() const {
    return static_cast<Net_EPlayerMoveType>(GetField<int8_t>(VT_MOVE_TYPE, 0));
  }
  bool flashlight() const {
    return GetField<uint8_t>(VT_FLASHLIGHT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_ANGLES, 4) &&
           VerifyField<int32_t>(verifier, VT_BUTTONS, 4) &&
           VerifyField<int8_t>(verifier, VT_MOVE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLASHLIGHT, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_UserCmdBuilder {
  typedef NetMsg_UserCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_angles(const Vec3 *angles) {
    fbb_.AddStruct(NetMsg_UserCmd::VT_ANGLES, angles);
  }
  void add_buttons(int32_t buttons) {
    fbb_.AddElement<int32_t>(NetMsg_UserCmd::VT_BUTTONS, buttons, 0);
  }
  void add_move_type(Net_EPlayerMoveType move_type) {
    fbb_.AddElement<int8_t>(NetMsg_UserCmd::VT_MOVE_TYPE, static_cast<int8_t>(move_type), 0);
  }
  void add_flashlight(bool flashlight) {
    fbb_.AddElement<uint8_t>(NetMsg_UserCmd::VT_FLASHLIGHT, static_cast<uint8_t>(flashlight), 0);
  }
  explicit NetMsg_UserCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_UserCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_UserCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_UserCmd> CreateNetMsg_UserCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *angles = nullptr,
    int32_t buttons = 0,
    Net_EPlayerMoveType move_type = Net_EPlayerMoveType_Walk,
    bool flashlight = false) {
  NetMsg_UserCmdBuilder builder_(_fbb);
  builder_.add_buttons(buttons);
  builder_.add_angles(angles);
  builder_.add_flashlight(flashlight);
  builder_.add_move_type(move_type);
  return builder_.Finish();
}

struct NetMsg_ServerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CLIENT_COUNT = 6,
    VT_MAX_CLIENTS = 8,
    VT_MAP_NAME = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint8_t client_count() const {
    return GetField<uint8_t>(VT_CLIENT_COUNT, 0);
  }
  uint8_t max_clients() const {
    return GetField<uint8_t>(VT_MAX_CLIENTS, 0);
  }
  const ::flatbuffers::String *map_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_CLIENT_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX_CLIENTS, 1) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerInfoBuilder {
  typedef NetMsg_ServerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ServerInfo::VT_NAME, name);
  }
  void add_client_count(uint8_t client_count) {
    fbb_.AddElement<uint8_t>(NetMsg_ServerInfo::VT_CLIENT_COUNT, client_count, 0);
  }
  void add_max_clients(uint8_t max_clients) {
    fbb_.AddElement<uint8_t>(NetMsg_ServerInfo::VT_MAX_CLIENTS, max_clients, 0);
  }
  void add_map_name(::flatbuffers::Offset<::flatbuffers::String> map_name) {
    fbb_.AddOffset(NetMsg_ServerInfo::VT_MAP_NAME, map_name);
  }
  explicit NetMsg_ServerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerInfo> CreateNetMsg_ServerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint8_t client_count = 0,
    uint8_t max_clients = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map_name = 0) {
  NetMsg_ServerInfoBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_name(name);
  builder_.add_max_clients(max_clients);
  builder_.add_client_count(client_count);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ServerInfo> CreateNetMsg_ServerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t client_count = 0,
    uint8_t max_clients = 0,
    const char *map_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return CreateNetMsg_ServerInfo(
      _fbb,
      name__,
      client_count,
      max_clients,
      map_name__);
}

struct NetMsg_ClientInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ClientInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STEAM_ID = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t steam_id() const {
    return GetField<uint64_t>(VT_STEAM_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ClientInfoBuilder {
  typedef NetMsg_ClientInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ClientInfo::VT_NAME, name);
  }
  void add_steam_id(uint64_t steam_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ClientInfo::VT_STEAM_ID, steam_id, 0);
  }
  explicit NetMsg_ClientInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ClientInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ClientInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ClientInfo> CreateNetMsg_ClientInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t steam_id = 0) {
  NetMsg_ClientInfoBuilder builder_(_fbb);
  builder_.add_steam_id(steam_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ClientInfo> CreateNetMsg_ClientInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t steam_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNetMsg_ClientInfo(
      _fbb,
      name__,
      steam_id);
}

struct NetMsg_ServerClientInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerClientInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STEAM_ID = 6,
    VT_ENTITY_ID = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t steam_id() const {
    return GetField<uint64_t>(VT_STEAM_ID, 0);
  }
  uint64_t entity_id() const {
    return GetField<uint64_t>(VT_ENTITY_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_ENTITY_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerClientInfoBuilder {
  typedef NetMsg_ServerClientInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ServerClientInfo::VT_NAME, name);
  }
  void add_steam_id(uint64_t steam_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerClientInfo::VT_STEAM_ID, steam_id, 0);
  }
  void add_entity_id(uint64_t entity_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerClientInfo::VT_ENTITY_ID, entity_id, 0);
  }
  explicit NetMsg_ServerClientInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerClientInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerClientInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerClientInfo> CreateNetMsg_ServerClientInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t steam_id = 0,
    uint64_t entity_id = 0) {
  NetMsg_ServerClientInfoBuilder builder_(_fbb);
  builder_.add_entity_id(entity_id);
  builder_.add_steam_id(steam_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ServerClientInfo> CreateNetMsg_ServerClientInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t steam_id = 0,
    uint64_t entity_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNetMsg_ServerClientInfo(
      _fbb,
      name__,
      steam_id,
      entity_id);
}

struct NetMsg_ServerConnectResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerConnectResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ENTITY_ID = 4
  };
  uint64_t client_entity_id() const {
    return GetField<uint64_t>(VT_CLIENT_ENTITY_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLIENT_ENTITY_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerConnectResponseBuilder {
  typedef NetMsg_ServerConnectResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_entity_id(uint64_t client_entity_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerConnectResponse::VT_CLIENT_ENTITY_ID, client_entity_id, 0);
  }
  explicit NetMsg_ServerConnectResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerConnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerConnectResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerConnectResponse> CreateNetMsg_ServerConnectResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t client_entity_id = 0) {
  NetMsg_ServerConnectResponseBuilder builder_(_fbb);
  builder_.add_client_entity_id(client_entity_id);
  return builder_.Finish();
}

struct NetMsg_ClientConnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ClientConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4
  };
  uint16_t protocol() const {
    return GetField<uint16_t>(VT_PROTOCOL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL, 2) &&
           verifier.EndTable();
  }
};

struct NetMsg_ClientConnectBuilder {
  typedef NetMsg_ClientConnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol(uint16_t protocol) {
    fbb_.AddElement<uint16_t>(NetMsg_ClientConnect::VT_PROTOCOL, protocol, 0);
  }
  explicit NetMsg_ClientConnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ClientConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ClientConnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ClientConnect> CreateNetMsg_ClientConnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol = 0) {
  NetMsg_ClientConnectBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

struct NetMsg_Disconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_DisconnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REASON = 4
  };
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct NetMsg_DisconnectBuilder {
  typedef NetMsg_Disconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(NetMsg_Disconnect::VT_REASON, reason);
  }
  explicit NetMsg_DisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_Disconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_Disconnect> CreateNetMsg_Disconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  NetMsg_DisconnectBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_Disconnect> CreateNetMsg_DisconnectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return CreateNetMsg_Disconnect(
      _fbb,
      reason__);
}

struct NetMsg_ConVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ConVarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ConVarBuilder {
  typedef NetMsg_ConVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(NetMsg_ConVar::VT_COMMAND, command);
  }
  explicit NetMsg_ConVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ConVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ConVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ConVar> CreateNetMsg_ConVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0) {
  NetMsg_ConVarBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ConVar> CreateNetMsg_ConVarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return CreateNetMsg_ConVar(
      _fbb,
      command__);
}

struct NetMsg_Paused FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_PausedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSED = 4
  };
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_PausedBuilder {
  typedef NetMsg_Paused Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(NetMsg_Paused::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  explicit NetMsg_PausedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_Paused> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_Paused>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_Paused> CreateNetMsg_Paused(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool paused = false) {
  NetMsg_PausedBuilder builder_(_fbb);
  builder_.add_paused(paused);
  return builder_.Finish();
}

struct NetMsg_GameRule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_GameRuleBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NetMsg_GameRuleBuilder {
  typedef NetMsg_GameRule Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NetMsg_GameRuleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_GameRule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_GameRule>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_GameRule> CreateNetMsg_GameRule(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NetMsg_GameRuleBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NetMsg_GameRuleList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_GameRuleListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_GameRule>> *rules() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_GameRule>> *>(VT_RULES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyVector(rules()) &&
           verifier.VerifyVectorOfTables(rules()) &&
           verifier.EndTable();
  }
};

struct NetMsg_GameRuleListBuilder {
  typedef NetMsg_GameRuleList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rules(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_GameRule>>> rules) {
    fbb_.AddOffset(NetMsg_GameRuleList::VT_RULES, rules);
  }
  explicit NetMsg_GameRuleListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_GameRuleList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_GameRuleList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_GameRuleList> CreateNetMsg_GameRuleList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_GameRule>>> rules = 0) {
  NetMsg_GameRuleListBuilder builder_(_fbb);
  builder_.add_rules(rules);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_GameRuleList> CreateNetMsg_GameRuleListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetMsg_GameRule>> *rules = nullptr) {
  auto rules__ = rules ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_GameRule>>(*rules) : 0;
  return CreateNetMsg_GameRuleList(
      _fbb,
      rules__);
}

struct MsgSrc_Client FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgSrc_ClientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  EMsgSrc_Client type() const {
    return static_cast<EMsgSrc_Client>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MsgSrc_ClientBuilder {
  typedef MsgSrc_Client Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(EMsgSrc_Client type) {
    fbb_.AddElement<uint8_t>(MsgSrc_Client::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MsgSrc_Client::VT_DATA, data);
  }
  explicit MsgSrc_ClientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgSrc_Client> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgSrc_Client>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgSrc_Client> CreateMsgSrc_Client(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Client type = EMsgSrc_Client_Invalid,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  MsgSrc_ClientBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MsgSrc_Client> CreateMsgSrc_ClientDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Client type = EMsgSrc_Client_Invalid,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateMsgSrc_Client(
      _fbb,
      type,
      data__);
}

struct MsgSrc_Server FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgSrc_ServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  EMsgSrc_Server type() const {
    return static_cast<EMsgSrc_Server>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MsgSrc_ServerBuilder {
  typedef MsgSrc_Server Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(EMsgSrc_Server type) {
    fbb_.AddElement<uint8_t>(MsgSrc_Server::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MsgSrc_Server::VT_DATA, data);
  }
  explicit MsgSrc_ServerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgSrc_Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgSrc_Server>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgSrc_Server> CreateMsgSrc_Server(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Server type = EMsgSrc_Server_Invalid,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  MsgSrc_ServerBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MsgSrc_Server> CreateMsgSrc_ServerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Server type = EMsgSrc_Server_Invalid,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateMsgSrc_Server(
      _fbb,
      type,
      data__);
}

struct NetMsg_ComponentUpdateData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdateDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUES = 6,
    VT_DESTROYED = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool destroyed() const {
    return GetField<uint8_t>(VT_DESTROYED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyField<uint8_t>(verifier, VT_DESTROYED, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdateDataBuilder {
  typedef NetMsg_ComponentUpdateData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(NetMsg_ComponentUpdateData::VT_ID, id, 0);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(NetMsg_ComponentUpdateData::VT_VALUES, values);
  }
  void add_destroyed(bool destroyed) {
    fbb_.AddElement<uint8_t>(NetMsg_ComponentUpdateData::VT_DESTROYED, static_cast<uint8_t>(destroyed), 0);
  }
  explicit NetMsg_ComponentUpdateDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdateData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdateData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdateData> CreateNetMsg_ComponentUpdateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0,
    bool destroyed = false) {
  NetMsg_ComponentUpdateDataBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_values(values);
  builder_.add_destroyed(destroyed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdateData> CreateNetMsg_ComponentUpdateDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const std::vector<uint8_t> *values = nullptr,
    bool destroyed = false) {
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return CreateNetMsg_ComponentUpdateData(
      _fbb,
      id,
      values__,
      destroyed);
}

struct NetMsg_ComponentUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HASH = 6,
    VT_COMPONENTS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *components() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *>(VT_COMPONENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_HASH, 8) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdateBuilder {
  typedef NetMsg_ComponentUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ComponentUpdate::VT_NAME, name);
  }
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(NetMsg_ComponentUpdate::VT_HASH, hash, 0);
  }
  void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>> components) {
    fbb_.AddOffset(NetMsg_ComponentUpdate::VT_COMPONENTS, components);
  }
  explicit NetMsg_ComponentUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdate> CreateNetMsg_ComponentUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t hash = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>> components = 0) {
  NetMsg_ComponentUpdateBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_components(components);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdate> CreateNetMsg_ComponentUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t hash = 0,
    const std::vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *components = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>(*components) : 0;
  return CreateNetMsg_ComponentUpdate(
      _fbb,
      name__,
      hash,
      components__);
}

struct NetMsg_EntityUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_EntityUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DESTROYED = 6,
    VT_PARENT = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool destroyed() const {
    return GetField<uint8_t>(VT_DESTROYED, 0) != 0;
  }
  uint64_t parent() const {
    return GetField<uint64_t>(VT_PARENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_DESTROYED, 1) &&
           VerifyField<uint64_t>(verifier, VT_PARENT, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_EntityUpdateBuilder {
  typedef NetMsg_EntityUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(NetMsg_EntityUpdate::VT_ID, id, 0);
  }
  void add_destroyed(bool destroyed) {
    fbb_.AddElement<uint8_t>(NetMsg_EntityUpdate::VT_DESTROYED, static_cast<uint8_t>(destroyed), 0);
  }
  void add_parent(uint64_t parent) {
    fbb_.AddElement<uint64_t>(NetMsg_EntityUpdate::VT_PARENT, parent, 0);
  }
  explicit NetMsg_EntityUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_EntityUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_EntityUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_EntityUpdate> CreateNetMsg_EntityUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    bool destroyed = false,
    uint64_t parent = 0) {
  NetMsg_EntityUpdateBuilder builder_(_fbb);
  builder_.add_parent(parent);
  builder_.add_id(id);
  builder_.add_destroyed(destroyed);
  return builder_.Finish();
}

struct NetMsg_EntityUpdates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_EntityUpdatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *update_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *>(VT_UPDATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATE_LIST) &&
           verifier.VerifyVector(update_list()) &&
           verifier.VerifyVectorOfTables(update_list()) &&
           verifier.EndTable();
  }
};

struct NetMsg_EntityUpdatesBuilder {
  typedef NetMsg_EntityUpdates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>>> update_list) {
    fbb_.AddOffset(NetMsg_EntityUpdates::VT_UPDATE_LIST, update_list);
  }
  explicit NetMsg_EntityUpdatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_EntityUpdates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_EntityUpdates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_EntityUpdates> CreateNetMsg_EntityUpdates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>>> update_list = 0) {
  NetMsg_EntityUpdatesBuilder builder_(_fbb);
  builder_.add_update_list(update_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_EntityUpdates> CreateNetMsg_EntityUpdatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *update_list = nullptr) {
  auto update_list__ = update_list ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_EntityUpdate>>(*update_list) : 0;
  return CreateNetMsg_EntityUpdates(
      _fbb,
      update_list__);
}

struct NetMsg_ComponentUpdates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *update_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *>(VT_UPDATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATE_LIST) &&
           verifier.VerifyVector(update_list()) &&
           verifier.VerifyVectorOfTables(update_list()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdatesBuilder {
  typedef NetMsg_ComponentUpdates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>> update_list) {
    fbb_.AddOffset(NetMsg_ComponentUpdates::VT_UPDATE_LIST, update_list);
  }
  explicit NetMsg_ComponentUpdatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdates> CreateNetMsg_ComponentUpdates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>> update_list = 0) {
  NetMsg_ComponentUpdatesBuilder builder_(_fbb);
  builder_.add_update_list(update_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdates> CreateNetMsg_ComponentUpdatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *update_list = nullptr) {
  auto update_list__ = update_list ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>(*update_list) : 0;
  return CreateNetMsg_ComponentUpdates(
      _fbb,
      update_list__);
}

struct SMF_Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SMF_CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_VERSION = 6,
    VT_DATA = 8
  };
  ESMF_Command command() const {
    return static_cast<ESMF_Command>(GetField<uint32_t>(VT_COMMAND, 0));
  }
  uint16_t version() const {
    return GetField<uint16_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMMAND, 4) &&
           VerifyField<uint16_t>(verifier, VT_VERSION, 2) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SMF_CommandBuilder {
  typedef SMF_Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(ESMF_Command command) {
    fbb_.AddElement<uint32_t>(SMF_Command::VT_COMMAND, static_cast<uint32_t>(command), 0);
  }
  void add_version(uint16_t version) {
    fbb_.AddElement<uint16_t>(SMF_Command::VT_VERSION, version, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SMF_Command::VT_DATA, data);
  }
  explicit SMF_CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SMF_Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SMF_Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SMF_Command> CreateSMF_Command(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ESMF_Command command = ESMF_Command_Invalid,
    uint16_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  SMF_CommandBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_command(command);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SMF_Command> CreateSMF_CommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ESMF_Command command = ESMF_Command_Invalid,
    uint16_t version = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateSMF_Command(
      _fbb,
      command,
      version,
      data__);
}

struct SMF_Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SMF_DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<SMF_Command>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SMF_Command>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct SMF_DataBuilder {
  typedef SMF_Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SMF_Command>>> commands) {
    fbb_.AddOffset(SMF_Data::VT_COMMANDS, commands);
  }
  explicit SMF_DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SMF_Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SMF_Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SMF_Data> CreateSMF_Data(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SMF_Command>>> commands = 0) {
  SMF_DataBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SMF_Data> CreateSMF_DataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<SMF_Command>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<SMF_Command>>(*commands) : 0;
  return CreateSMF_Data(
      _fbb,
      commands__);
}

struct SMF_Skybox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SMF_SkyboxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4
  };
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           verifier.EndTable();
  }
};

struct SMF_SkyboxBuilder {
  typedef SMF_Skybox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(SMF_Skybox::VT_MATERIAL, material);
  }
  explicit SMF_SkyboxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SMF_Skybox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SMF_Skybox>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SMF_Skybox> CreateSMF_Skybox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0) {
  SMF_SkyboxBuilder builder_(_fbb);
  builder_.add_material(material);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SMF_Skybox> CreateSMF_SkyboxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *material = nullptr) {
  auto material__ = material ? _fbb.CreateString(material) : 0;
  return CreateSMF_Skybox(
      _fbb,
      material__);
}

#endif  // FLATBUFFERS_GENERATED_SIDURY_H_
